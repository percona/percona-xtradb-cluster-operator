#!/bin/bash

set -o errexit

test_dir=$(realpath $(dirname $0))
. "${test_dir}"/../functions

set_debug

is_password_updated() {
	local username=$1
	local uri=$2
	run_mysql "SELECT User_attributes FROM mysql.user WHERE user='${username}'" "${uri}" | grep additional_password
}

is_old_password_discarded() {
	local username=$1
	local uri=$2
	echo "=== DEBUG is_old_password_discarded: Starting check for user=${username} ===" >&2
	local result
	echo "=== DEBUG is_old_password_discarded: About to call run_mysql ===" >&2
	local mysql_start=$(date +%s)
	result=$(run_mysql "SELECT User_attributes FROM mysql.user WHERE user='${username}'" "${uri}" 2>/dev/null || echo "")
	local mysql_end=$(date +%s)
	local mysql_duration=$((mysql_end - mysql_start))
	echo "=== DEBUG is_old_password_discarded: run_mysql completed in ${mysql_duration}s, result length=${#result} ===" >&2
	echo "=== DEBUG is_old_password_discarded: result='${result:0:200}' ===" >&2
	
	# If result contains additional_password, old password is still present (not discarded)
	if [[ "$result" =~ additional_password ]]; then
		echo "=== DEBUG is_old_password_discarded: Found 'additional_password' in result, returning 1 (NOT discarded) ===" >&2
		return 1
	fi
	# If result is empty, NULL, or whitespace only, old password is discarded
	if [[ -z "$result" ]] || [[ "$result" =~ ^[[:space:]]*$ ]] || [[ "$result" =~ NULL ]]; then
		echo "=== DEBUG is_old_password_discarded: Result is empty/NULL/whitespace, returning 0 (IS discarded) ===" >&2
		return 0
	fi
	# Default: if we can't determine, assume not discarded (fail safe)
	echo "=== DEBUG is_old_password_discarded: Cannot determine state, defaulting to NOT discarded, returning 1 ===" >&2
	return 1
}

wait_for_password_propagation() {
	local secret=$1
	local user=$2
	local cluster=$3
	local max_retry="${4:-600}"
	local root_pass
	local retry

	# Error handling for getSecretData
	if ! root_pass=$(getSecretData "${secret}" "root"); then
		echo "ERROR: Failed to get root password from secret ${secret}"
		return 1
	fi

	# Validate root_pass is not empty
	if [[ -z "${root_pass}" ]]; then
		echo "ERROR: Root password is empty"
		return 1
	fi

	if [[ $IMAGE_PXC =~ 5\.7 ]]; then
		echo "Skipping dual password feature doesn't work for 5.7. PXC 5.7 doesn't support it!"
		return 0
	fi

	retry=0
	until is_password_updated "${user}" "-h ${cluster}-pxc -uroot -p'${root_pass}'"; do
		echo "waiting for password update"
		sleep 1
		retry=$((retry + 1))
		if [[ $retry -ge $max_retry ]]; then
			echo "ERROR: max retry count $retry reached. something went wrong with operator or kubernetes cluster"
			return 1
		fi
	done

	# Give operator some time to start processing before checking
	sleep 5
	
	retry=0
	echo "=== DEBUG: Starting to wait for old password to be discarded (max ${max_retry} retries) ===" >&2
	echo "=== DEBUG: user=${user}, cluster=${cluster} ===" >&2
	while true; do
		echo "=== DEBUG: Loop iteration start, retry=$retry ===" >&2
		
		# Check if old password is discarded
		echo "=== DEBUG: About to call is_old_password_discarded for user=${user} ===" >&2
		local check_start_time=$(date +%s)
		if is_old_password_discarded "${user}" "-h ${cluster}-pxc -uroot -p'${root_pass}'"; then
			local check_end_time=$(date +%s)
			local check_duration=$((check_end_time - check_start_time))
			echo "=== DEBUG: is_old_password_discarded returned SUCCESS (exit code 0) after ${check_duration}s ===" >&2
			echo "=== DEBUG: Old password is discarded! Breaking loop. ===" >&2
			break
		fi
		local check_end_time=$(date +%s)
		local check_duration=$((check_end_time - check_start_time))
		echo "=== DEBUG: is_old_password_discarded returned FAILURE (exit code 1) after ${check_duration}s ===" >&2
		echo "=== DEBUG: Old password still present, continuing loop... ===" >&2
		
		if [[ $retry -eq 0 ]]; then
			echo "waiting for old password to be discarded... (retry $retry/$max_retry)"
		fi
		
		echo "=== DEBUG: About to sleep 1 second ===" >&2
		sleep 1
		echo "=== DEBUG: Sleep completed ===" >&2
		
		echo "=== DEBUG: About to increment retry (current: $retry) ===" >&2
		retry=$((retry + 1))
		echo "=== DEBUG: Retry incremented to $retry ===" >&2
		
		# Show progress every retry to both stdout and stderr
		echo "retry=$retry (checking again...)"
		echo "=== DEBUG: retry=$retry (will check again in next iteration) ===" >&2
		
		if [[ $((retry % 30)) -eq 0 ]] && [[ $retry -gt 0 ]]; then
			# Show debug info every 30 retries
			echo "=== DEBUG: Getting detailed User_attributes (retry $retry) ===" >&2
			local debug_result
			debug_result=$(run_mysql "SELECT User_attributes FROM mysql.user WHERE user='${user}'" "-h ${cluster}-pxc -uroot -p'${root_pass}'" 2>/dev/null || echo "ERROR")
			echo "waiting for password propagation (retry $retry/$max_retry). User_attributes: ${debug_result:0:100}"
			echo "=== DEBUG: Full User_attributes: $debug_result ===" >&2
		elif [[ $((retry % 10)) -eq 0 ]] && [[ $retry -gt 0 ]]; then
			# Show progress every 10 retries (but not on retry 0)
			echo "waiting for old password to be discarded... (retry $retry/$max_retry)"
		fi
		
		if [[ $((retry % 5)) -eq 0 ]]; then
			echo "still waiting... (retry $retry/$max_retry)" >&2
		fi
		
		if [[ $retry -ge $max_retry ]]; then
			echo "=== DEBUG: Max retry count reached! ===" >&2
			echo "ERROR: max retry count $retry reached. something went wrong with operator or kubernetes cluster"
			echo "=== DEBUG: Getting final User_attributes value ===" >&2
			local final_result
			final_result=$(run_mysql "SELECT User_attributes FROM mysql.user WHERE user='${user}'" "-h ${cluster}-pxc -uroot -p'${root_pass}'" 2>/dev/null || echo "ERROR")
			echo "Final User_attributes value: $final_result"
			echo "=== DEBUG: Full final User_attributes: $final_result ===" >&2
			echo "This means the operator did not discard the old password within ${max_retry} seconds"
			return 1
		fi
		echo "=== DEBUG: End of loop iteration, retry=$retry, continuing... ===" >&2
	done
	echo "=== DEBUG: Loop exited successfully ===" >&2
	echo "Old password successfully discarded after $retry retries"
}

create_infra "$namespace"

desc 'create PXC cluster with 1-password secret'

newpass="test-password"
newpassencrypted=$(echo -n "$newpass" | base64)

cluster="some-name"
spinup_pxc "$cluster" "${test_dir}/conf/${cluster}.yml" "" "" "$conf_dir/secrets_one_pass.yml"

PROXYSQL_VER=$(kubectl exec -it $cluster-proxysql-0 -- sh -c 'proxysql --version 2>/dev/null' | awk '{print $3}' | cut -d. -f1)
tables_cmp_file="select-2-proxysql3"
if [[ $PROXYSQL_VER == 2 ]]; then
	tables_cmp_file="select-2"
fi

desc 'test missing passwords were created and present in internal secrets'
empty_pwds=()
wrong_pwds=()
for user in root xtrabackup monitor proxyadmin operator replication; do
	echo "Checking $user"
	secret_pass=$(getSecretData "my-cluster-secrets" "$user")
	int_secret_pass=$(getSecretData "internal-some-name" "$user")
	if [[ -z ${secret_pass} ]]; then
		empty_pwds+=("${user}")
	fi
	if [[ ${secret_pass} != "${int_secret_pass}" ]]; then
		wrong_pwds+=("${user}")
	fi
	if [[ ${user} != 'proxyadmin' ]] && ! [[ ${empty_pwds[*]} =~ ${user} ]] && ! [[ ${wrong_pwds[*]} =~ ${user} ]]; then
		echo "Running compare for ${user}"
		compare_mysql_cmd "select-4" "SHOW TABLES;" "-h ${cluster}-proxysql -u${user} -p'${secret_pass}'"
	elif [[ ${user} == 'proxyadmin' ]] && ! [[ ${empty_pwds[*]} =~ ${user} ]] && ! [[ ${wrong_pwds[*]} =~ ${user} ]]; then
		echo "Running compare for ${user}"
		compare_mysql_cmd_local "$tables_cmp_file" "SHOW TABLES;" "-h127.0.0.1 -P6032 -u${user} -p'${secret_pass}'" "${cluster}-proxysql-0" "" 'proxysql'
	fi
done
if [[ -n ${empty_pwds[*]} || -n ${wrong_pwds[*]} ]]; then
	echo "Passwords for the following users were empty: ${empty_pwds[*]:-none}"
	echo "Passwords for the following users were wrong: ${wrong_pwds[*]:-none}"
	exit 1
fi

desc 'test root'
patch_secret "my-cluster-secrets" "root" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 2
sleep 15
compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -uroot -p'$newpass'"

desc 'test proxyadmin'
kubectl_bin patch pxc some-name --type=merge -p="{\"spec\":{\"proxysql\":{\"size\":3}}}"
sleep 15
wait_cluster_consistency "$cluster" 3 3
patch_secret "my-cluster-secrets" "proxyadmin" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 3
sleep 15
compare_mysql_cmd_local "$tables_cmp_file" "SHOW TABLES;" "-h127.0.0.1 -P6032 -uproxyadmin -p'$newpass'" "$cluster-proxysql-0" "" 'proxysql'
compare_mysql_cmd_local "$tables_cmp_file" "SHOW TABLES;" "-h127.0.0.1 -P6032 -uproxyadmin -p'$newpass'" "$cluster-proxysql-1" "" 'proxysql'
compare_mysql_cmd_local "$tables_cmp_file" "SHOW TABLES;" "-h127.0.0.1 -P6032 -uproxyadmin -p'$newpass'" "$cluster-proxysql-2" "" 'proxysql'

desc 'test xtrabackup'
kubectl_bin patch pxc some-name --type=merge -p="{\"spec\":{\"proxysql\":{\"size\":2}}}"
patch_secret "my-cluster-secrets" "xtrabackup" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 2
sleep 15
compare_mysql_cmd_local "select-3" "SHOW DATABASES;" "-h 127.0.0.1 -uxtrabackup -p'$newpass'" "$cluster-pxc-0" "" 'pxc'

desc 'test monitor'
patch_secret "my-cluster-secrets" "monitor" "$newpassencrypted"
wait_for_password_propagation "my-cluster-secrets" "monitor" "$cluster"
wait_cluster_consistency "$cluster" 3 2
sleep 15 # give some time for proxy-admin --syncusers
compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -umonitor -p'$newpass'"

desc 'test operator'
patch_secret "my-cluster-secrets" "operator" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 2
sleep 15 # give some time for proxy-admin --syncusers
compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -uoperator -p'$newpass'"

desc 'change secret name'
kubectl_bin patch pxc $cluster --type merge --patch '{"spec": {"secretsName":"my-cluster-secrets-2"}}'
sleep 15
wait_cluster_consistency "$cluster" 3 2

desc 'test new operator'
newpass="test-password2"
newpassencrypted=$(echo -n "$newpass" | base64)
patch_secret "my-cluster-secrets-2" "operator" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 2

sleep 20 # give some time for proxy-admin --syncusers

compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -uoperator -p'$newpass'"

newpass=$(getSecretData "my-cluster-secrets-2" "root")
desc 'test new users sync'
run_mysql \
	"CREATE USER 'testsync'@'%' IDENTIFIED BY '$newpass';" \
	"-h $cluster-pxc -uroot -p'$newpass'"
sleep 80
compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -utestsync -p'$newpass'"

pass=$(getSecretData "internal-some-name" "operator")
desc 'check secret without operator'
kubectl_bin apply \
	-f "$test_dir/conf/secrets.yml"
sleep 60
compare_mysql_cmd "select-4" "SHOW TABLES;" "-h $cluster-proxysql -uoperator -p'$pass'"

desc 'test enable haproxy and disable proxysql '
newpass="test-password2"
newpassencrypted=$(echo -n "$newpass" | base64)
kubectl_bin patch pxc ${cluster}  --type=merge -p '{"spec":{"haproxy":{"enabled":true},"proxysql":{"enabled":false},"secretsName":"my-cluster-secrets"}}'

sleep 15
wait_cluster_consistency "$cluster" 3 3
if [[ $IMAGE_PXC =~ 5\.7 ]]; then
	check_generation "2" "haproxy" "${cluster}"
else
	check_generation "1" "haproxy" "${cluster}"
fi
patch_secret "my-cluster-secrets" "monitor" "$newpassencrypted"
sleep 15
wait_cluster_consistency "$cluster" 3 3
sleep 15
compare_mysql_cmd "select-3" "SHOW DATABASES;" "-h $cluster-haproxy -umonitor -p'$newpass'"

if [[ $IMAGE_PXC =~ 5\.7 ]]; then
	check_generation "3" "haproxy" "${cluster}"
else
	check_generation "1" "haproxy" "${cluster}"
fi

destroy "${namespace}"
desc "test passed"
